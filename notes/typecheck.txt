ref: transparent
box: translucent
tag: opaque

inferring type arguments based on arguments can be done later
  when done, more function types can be subtypes of other function types

what about capabilities for typeargs?
to allow any cap:
  it could be tag, so can't read or write
  it could be mut, so can't send
  it could be iso, so can't alias as our own type
if we want to read
  can't be tag
if we want to write
  can't be imm, box, tag
if we want to send
  can't be trn, mut, box
could specify a set of capabilities?
  A: Foo {iso, tag}
simpler: just make it a subtype relationship
  then type check the class again with the typeargs
  mark methods that don't typecheck with those typeargs as unavailable
  can use this to supply some functions only when certain conditions are met

implicit recover?
  for any expression that accesses only sendable identifiers

expression typing
  atom
    * THIS
    * INT
    * FLOAT
    * STRING
    * REFERENCE
    * TUPLE
    - ARRAY
    - OBJECT
  postfix
    ? DOT field viewpoint
    * QUALIFY
    ? CALL infer type params
  unop
    * NOT
    * MINUS
    ? CONSUME invalidate id
    ? RECOVER remove things from scope
  * local
    * VAR/LET
    * AS
  control
    * IF
    ? MATCH unreachable cases, exhaustive match
    * CASES
    ? CASE patterns
    * WHILE
    * REPEAT
    * FOR
    * TRY
    * BREAK
    * CONTINUE
    * RETURN
    * ERROR
  binop
    * AND
    * OR
    * XOR
    * PLUS
    * MINUS
    * MULTIPLY
    * DIVIDE
    * MOD
    * LSHIFT
    * RSHIFT
    * IS
    * ISNT
    * EQ
    * NE
    * LT
    * LE
    * GE
    * GT
    ? ASSIGN viewpoint, safe to write
  * seq

// notes from sophia
should this->T be This->T?

instead of where clause, a different assignment?
a.b(c = 7, d := "foo")

only check exhaustive match for matching on type?

infer type args on constructors: attribute grammars?
  placeholder for unresolved type params

send syntax and semantics(?) of traits and generics to sophia
