replace package in nominal types with some global id?

implicit recover?
  for any expression that accesses only sendable identifiers

expression typing
  atom
    * THIS
    * INT
    * FLOAT
    * STRING
    * REFERENCE
    * TUPLE
    - ARRAY
    - OBJECT
  postfix
    * DOT
    * QUALIFY
    ? CALL infer type params
  unop
    * NOT
    * MINUS
    ? CONSUME invalidate id
    ? RECOVER remove things from scope
  * local
    * VAR/LET
    * AS
  control
    * IF
    ? MATCH unreachable cases, exhaustive match
    * CASES
    ? CASE patterns
    * WHILE
    * REPEAT
    * FOR
    * TRY
    * BREAK
    * CONTINUE
    * RETURN
    * ERROR
  * binop
    * AND
    * OR
    * XOR
    * PLUS
    * MINUS
    * MULTIPLY
    * DIVIDE
    * MOD
    * LSHIFT
    * RSHIFT
    * IS
    * ISNT
    * EQ
    * NE
    * LT
    * LE
    * GE
    * GT
    * ASSIGN
  * seq

// notes from sophia
should this->T be This->T?

instead of where clause, a different assignment?
a.b(c = 7, d := "foo")

only check exhaustive match for matching on type?

infer type args on constructors: attribute grammars?
  placeholder for unresolved type params

send syntax and semantics(?) of traits and generics to sophia
