#ifndef UNIT_UTIL_H
#define UNIT_UTIL_H

#include <gtest/gtest.h>
#include <platform.h>

#include <ast/ast.h>

// Provide a short alias for ASSERT_NO_FATAL_FAILURE
#define DO(...) ASSERT_NO_FATAL_FAILURE(__VA_ARGS__)


class PassTest : public testing::Test
{
protected:
  ast_t* program; // AST produced from given source
  ast_t* package; // AST of first package, cache of ast_child(program)
  ast_t* module;  // AST of first module in first package
  ast_t* walk_ast; // AST walked to
  ast_t* prog_type_1; // Type generated by program
  ast_t* prog_type_2; // Type generated by program
  ast_t* prog_type_3; // Type generated by program
  ast_t* prog_type_4; // Type generated by program

  virtual void SetUp();
  virtual void TearDown();

  // Override the default builtin source
  void set_builtin(const char* src);

  // Add an additional package source
  void add_package(const char* path, const char* src);

  // Override the default path of the main package (useful for package loops)
  void default_package_name(const char* path);

  // Count the number of symbol table references to the specified name in all
  // symbol tables in the given tree
  size_t ref_count(ast_t* ast, const char* name);

  // Check that the 2 given chunks of AST are the same. Siblings of the ASTs
  // are ignored.
  // Errors are checked with ASSERTs, call in ASSERT_NO_FATAL_FAILURE.
  void check_ast_same(ast_t* expect, ast_t* actual);

  // Generate a program containing the specified types. The resulting ASTs are
  // stored in the prog_type_* members.
  // Pass NULL for any unneeded types.
  // The extra_src param gives any extra Pony src, such as typedefs, needed.
  // Pass "" for this if not needed.
  // Errors are checked with ASSERTs, call in ASSERT_NO_FATAL_FAILURE.
  void generate_types(const char* extra_src, const char* type1,
    const char* type2, const char* type3, const char* type4);


  // Test methods.
  // These all build the given src code, up to the specified pass, and check
  // the resulting tree as required.
  // On successful build the resulting AST is stored in the program member with
  // the package and module members pointing to the appropriate nodes.
  // These methods all use ASSERTs, call in ASSERT_NO_FATAL_FAILURE.

  // Check that the given source compiles to the specified pass without error
  void test_compile(const char* src, const char* pass);

  // Check that the given source fails when compiled to the specified pass
  void test_error(const char* src, const char* pass);

  // Check that the 2 given sources compile to give the same AST for the first
  // package
  void test_equiv(const char* actual_src, const char* actual_pass,
    const char* expect_src, const char* expect_pass);


  // Walk methods.
  // These traverse a previously created AST, with the walk_ast member pointing
  // to the current location. At every step it is asserted that the current
  // location exists.
  // These methods all use ASSERTs, call in ASSERT_NO_FATAL_FAILURE.

  // Start walking at the specifier AST node
  void walk(ast_t* start);

  // Walk to the specified child of the current node
  void child(size_t index);

  // Walk to the sibling of the current node
  void sibling();

  // Walk to the parent of the current node
  void parent();

  // Walk to the type of the current node
  void type();

  // Check that the current node exists as is the specified id
  void check(token_id expected_id);


  // Lookup methods.
  // These lookup the given name in the symbol table of the relevant AST node
  // and walk to the node found.
  // All methods have a version that checks the resulting node exists and is
  // the specified id.
  // These methods all use ASSERTs, call in ASSERT_NO_FATAL_FAILURE.

  // Lookup the given name in the symbol table of the specified AST node
  void lookup_in(ast_t* ast, const char* name);
  void lookup_in(ast_t* ast, const char* name, token_id expected_id);

  // Lookup the given name in the symbol table of the current AST node
  void lookup(const char* name);
  void lookup(const char* name, token_id expected_id);

  // Lookup the type with the given name in the loaded previously package
  void lookup_type(const char* name);
  void lookup_type(const char* name, token_id expected_id);

  // Lookup the member with the given name in the type with the given name in
  // the loaded previously package
  void lookup_member(const char* type_name, const char* member_name);
  void lookup_member(const char* type_name, const char* member_name,
    token_id expected_id);

private:
  const char* _builtin_src;
  const char* _first_pkg_path;

  // Attempt to compile the package with the specified name into a program.
  // Errors are checked with ASSERTs, call in ASSERT_NO_FATAL_FAILURE.
  void build_package(const char* pass, const char* src,
    const char* package_name, bool check_good, ast_t** out_package);
};


#endif
